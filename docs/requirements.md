# リアルタイムアンケートシステム 要件定義書

## 1. 目的と概要

### 1.1 目的
本システムは、プレゼンテーションやミーティング中に参加者からフィードバックをリアルタイムで収集し、視覚化するためのウェブアプリケーションを提供することを目的とする。
Teams や Zoom などのビデオ会議ツールと併用して使用することを想定している。

### 1.2 概要
プレゼンター（発表者）は画面の左半分にアンケート質問と回答結果をリアルタイムで表示し、右半分にはQRコードを表示する。
参加者はQRコードをスキャンしてアンケートに回答し、その結果がリアルタイムでプレゼンターの画面に反映される。

### 1.3 開発アプローチ
本システムは、AI駆動開発（AI-Driven Development）アプローチを採用している。具体的には、Vercelが提供するAIアシスタント「v0」と個人開発者の協働により開発を進める。このアプローチにより、開発効率の向上と高品質なコード生成を実現する。

## 2. 機能要件

### 2.1 基本機能
- アンケート表示機能: 質問と回答結果を表示する画面
- 回答入力機能: 参加者が回答を入力する画面
- QRコード生成機能: アンケート回答ページへのアクセス用QRコードの生成
- リアルタイム更新機能: 回答がリアルタイムで集計・表示される機能
- 管理者機能: アンケートの作成・編集・管理機能

### 2.2 質問タイプ
- 選択式質問: 複数の選択肢から一つを選ぶ形式
- テキスト入力質問: 自由記述形式
- 評価質問: 1〜5段階で評価する形式

### 2.3 画面構成
- メイン画面（プレゼンター用）:
  - 左側2/3: 質問表示と回答結果のグラフ表示
  - 右側1/3: QRコードと管理者リンク
- 回答画面（参加者用）:
  - アンケートタイトルと説明
  - 質問と回答入力フォーム
  - 送信ボタン
- 管理者画面:
  - アンケートタイトル・説明の編集
  - 質問の追加・編集・削除
  - 回答のリセット

### 2.4 データ管理
- アンケートタイトルと説明の保存
- 質問内容と選択肢の保存
- 回答データの収集と集計
- 回答データのリアルタイム更新

## 3. 非機能要件

### 3.1 パフォーマンス
- 回答送信から表示更新までの遅延は2秒以内
- 同時に最大100人の参加者が回答できること
- 画面の読み込み時間は3秒以内

### 3.2 セキュリティ
- 管理者画面へのアクセス制限（将来的に実装）
- データの改ざん防止

### 3.3 可用性
- システムの稼働率は99.5%以上
- 計画的なメンテナンス以外でのダウンタイムは最小限に抑える

### 3.4 ユーザビリティ
- 直感的で使いやすいUI/UX
- レスポンシブデザインによる様々なデバイスへの対応
- アクセシビリティへの配慮

### 3.5 拡張性
- 将来的な機能追加が容易な設計
- データベース連携が可能な構造

## 4. ユーザーストーリー

### 4.1 プレゼンター（発表者）
- プレゼンターとして、アンケートを作成・編集したい
- プレゼンターとして、参加者の回答をリアルタイムで確認したい
- プレゼンターとして、アンケート結果をグラフで視覚的に把握したい
- プレゼンターとして、質問を切り替えて表示したい
- プレゼンターとして、必要に応じて回答データをリセットしたい

### 4.2 参加者
- 参加者として、QRコードをスキャンして簡単にアンケートにアクセスしたい
- 参加者として、質問に対して簡単に回答したい
- 参加者として、回答が正常に送信されたことを確認したい
- 参加者として、複数の質問に連続して回答したい

## 5. 技術要件

### 5.1 フロントエンド
- Next.js 15を使用したReactアプリケーション
- Tailwind CSSによるスタイリング
- shadcn/uiコンポーネントライブラリの活用
- Rechartsによるデータ可視化
- QRCode.reactによるQRコード生成
- Zustandによる状態管理

### 5.2 バックエンド
- Next.js Server Actionsによるサーバーサイドロジック
- 初期段階ではインメモリデータストレージを使用
- 将来的にはデータベース連携を想定

### 5.3 通信
- 初期段階ではポーリングによるデータ更新（2秒間隔）
- 将来的にはWebSocketによるリアルタイム通信を想定

## 6. AI駆動開発（AI-Driven Development）

### 6.1 Why：なぜAIを使うのか？
本プロジェクトでAI駆動開発を採用する理由は以下の通りである：

1. **開発速度の向上**：
   - 個人開発者の限られたリソースを最大限に活用するため
   - 反復的なコーディング作業を効率化し、創造的な問題解決に集中するため
   - プロトタイプから製品化までの時間を短縮するため

2. **コード品質の向上**：
   - AIが最新のベストプラクティスを適用したコードを生成するため
   - 一貫性のあるコーディングスタイルとパターンを維持するため
   - 人間が見落としがちなエッジケースや最適化の機会を発見するため

3. **技術的な知識の補完**：
   - 個人開発者が専門外の技術領域（例：データ可視化、リアルタイム通信）を効率的に実装するため
   - 最新のライブラリやフレームワークの活用方法を学習するため
   - 複雑な技術的課題に対する多角的なアプローチを検討するため

4. **イノベーションの促進**：
   - AIとの対話を通じて新しいアイデアや解決策を発見するため
   - 従来の開発手法では思いつかなかった実装方法を模索するため
   - AI駆動開発自体の可能性と限界を探求するため

### 6.2 What：何をAIが担うのか？
AIと人間の役割分担を明確にし、それぞれの強みを活かした開発プロセスを構築する：

1. **AIが担当する領域**：
   - コードの生成と実装案の提案
   - 一般的なUIコンポーネントの設計
   - データモデルとAPIの設計
   - エラーハンドリングとバリデーションロジックの実装
   - 基本的なテストケースの提案
   - ドキュメントの下書き作成
   - バグ修正案の提示
   - パフォーマンス最適化の提案

2. **人間（開発者）が担当する領域**：
   - プロジェクトの目的と要件の定義
   - ビジネスロジックの正確性の確認
   - AIが生成したコードのレビューと調整
   - ユーザー体験（UX）の最終判断
   - セキュリティ関連の実装の検証
   - 最終的なテスト戦略の決定
   - デプロイと運用の管理
   - ユーザーフィードバックに基づく改善判断

3. **協働が必要な領域**：
   - アーキテクチャの設計と決定
   - 技術スタックの選定
   - コードの品質とパフォーマンスの最適化
   - 複雑なビジネスロジックの実装
   - エッジケースの特定と対応
   - ユーザーインターフェースの改善
   - 技術的負債の管理

4. **AIから人間への移行ポイント**：
   - 生成されたコードが期待通りに動作しない場合
   - ビジネスロジックが複雑で文脈理解が必要な場合
   - セキュリティに関わる重要な実装の場合
   - パフォーマンスが要件を満たさない場合
   - ユーザー体験に関する主観的な判断が必要な場合
   - 倫理的な判断や法的考慮が必要な場合

### 6.3 How：どのように管理するのか？
AI駆動開発プロセスの管理方法と今後の運用計画：

1. **バージョン管理とコード追跡**：
   - すべてのコードはGitHubリポジトリで管理（setowatson/Realtime_Questionnaire）
   - AIが生成したコードは特定のコミットメッセージでマーク（例: "AI-generated: 機能名"）
   - 重要な変更点はPRとして管理し、AIの提案と人間の修正を明確に区別
   - コミットメッセージにAIとの対話セッション番号を含めて追跡可能性を確保

2. **品質管理プロセス**：
   - AIが生成したコードに対する標準的なレビューチェックリストの作成
   - 自動テストによる基本的な機能検証
   - 定期的なコード品質メトリクスの測定（複雑性、重複、テストカバレッジ）
   - セキュリティスキャンツールによる定期的な検証

3. **知識管理と継続的改善**：
   - 効果的なプロンプトとAIとの対話パターンのライブラリ化
   - AI駆動開発の成功事例と課題の文書化
   - 開発プロセスの振り返りと改善点の特定
   - AIの能力と限界に関する知見の蓄積

4. **長期的な運用計画**：
   - AIツールの進化に合わせた開発プロセスの更新
   - 人間の開発スキルとAI活用スキルの両方を継続的に向上
   - コードベースの一部を定期的にリファクタリングし、技術的負債を管理
   - AIが生成したコードの長期的なメンテナンス性の評価と改善

5. **ドキュメント管理**：
   - AIが生成したドキュメントの人間によるレビューと承認プロセス
   - コードとドキュメントの一貫性を確保するための定期的なチェック
   - AIとの対話履歴の保存と重要な決定事項の文書化
   - 開発プロセスとAI活用のベストプラクティスの継続的な更新

### 6.4 What-if：生成AIの不確実性/失敗にどう備えるか？
AI駆動開発における不確実性や失敗に対する備えと対応策：

1. **AIが不正確なコードを生成した場合**：
   - 実装前の徹底的なコードレビューを標準プロセスとして確立
   - 自動テストによる機能検証の徹底（単体テスト、統合テスト）
   - 段階的な実装とテストによる早期の問題発見
   - エラーパターンのライブラリ化と再発防止策の文書化

2. **AIが最新の技術情報を持っていない場合**：
   - AIの知識カットオフ日（2023年）を常に意識した開発計画
   - 最新技術に関しては公式ドキュメントを優先的に参照
   - 技術スタックの選定時に安定性と成熟度を重視
   - 開発者による最新技術トレンドの定期的な調査と補完

3. **AIが複雑な要件を誤解した場合**：
   - 要件を小さな単位に分割して段階的に指示
   - 具体的な例やユースケースを含めた明確な指示
   - 生成されたコードと要件の一致を確認するチェックリストの活用
   - 複雑な要件は図表やフローチャートで視覚化して伝達

4. **AIが生成したコードにセキュリティ脆弱性がある場合**：
   - セキュリティスキャンツールによる定期的な検証
   - OWASP Top 10などのセキュリティチェックリストの活用
   - 認証・認可・データ処理部分の特に慎重なレビュー
   - 外部からの入力データに対する徹底的なバリデーション

5. **AIが一貫性のない設計を提案した場合**：
   - アーキテクチャ設計原則とパターンの事前定義
   - 定期的な全体設計レビューの実施
   - コンポーネント間の依存関係の可視化と管理
   - 技術的負債の早期発見と計画的な解消

6. **AIの応答が遅い、または利用できない場合**：
   - 重要なコードセグメントのテンプレートやスニペットのローカル保存
   - 代替のAIツールや開発リソースの確保
   - クリティカルな開発タスクの優先順位付けと時間管理
   - 手動での実装に切り替えるための明確な判断基準の設定

7. **AIが提案した実装が性能要件を満たさない場合**：
   - パフォーマンス要件の明確な定義と測定方法の確立
   - 早期からのパフォーマンステストの実施
   - ボトルネックの特定と最適化のための専門知識の活用
   - 段階的な負荷テストによる性能検証

8. **AIが生成したコードの保守性が低い場合**：
   - コード品質メトリクス（複雑度、結合度など）の定期的な測定
   - リファクタリングのためのタイムボックスの計画的な確保
   - コーディング規約とベストプラクティスの文書化と遵守
   - コードの自己文書化（適切な命名、コメント）の徹底

これらの対策を事前に計画し、AI駆動開発の不確実性に備えることで、プロジェクトの成功確率を高め、リスクを最小化する。また、発生した問題と解決策を記録することで、将来のAI駆動プロジェクトにおける知見として活用する。

### 6.5 AI駆動開発のプロセス
1. 開発者がAIに機能要件を提示
2. AIがコード生成と実装案を提案
3. 開発者がコードをレビューし、必要に応じて調整
4. 開発者とAIの対話を通じて機能を改善・拡張
5. 開発者による最終確認とデプロイ

### 6.6 AI駆動開発の利点
- 開発速度の向上: AIによる迅速なコード生成
- コード品質の向上: AIが最新のベストプラクティスを適用
- 学習と知識共有: 開発者がAIとの対話を通じて新技術を学習
- 柔軟な開発: 要件変更に対する迅速な対応

### 6.7 AI駆動開発における課題と対策
- コード品質の確保: 開発者によるレビューと品質チェック
- セキュリティリスク: AIが生成したコードのセキュリティレビュー
- 責任の所在: 最終的な判断と責任は開発者が持つ
- 依存性の管理: AIが提案するライブラリの適切な選定

## 7. 制約条件

### 7.1 技術的制約
- サーバーレス環境での動作を前提とする
- 初期段階ではデータの永続化は行わない（サーバー再起動でデータは消失）
- ブラウザの互換性はモダンブラウザ（Chrome, Firefox, Safari, Edge最新版）のみ保証

### 7.2 ビジネス制約
- 初期開発期間は2週間以内
- 最小限の機能で早期にリリースし、フィードバックを得ながら改善する

### 7.3 AI駆動開発における制約
- AIの提案するコードは常に人間のレビューを経る
- AIの知識の限界（2023年までの情報）を考慮した開発計画
- AIが生成したコードの著作権と利用規約の遵守
- AIへの過度な依存を避け、開発者のスキル維持を重視

## 8. 将来の拡張性

### 8.1 短期的な拡張（3ヶ月以内）
- データベース連携（MongoDB, PostgreSQL, Supabaseなど）
- 管理者認証機能
- 回答データのエクスポート機能（CSV, Excel）

### 8.2 中長期的な拡張（6ヶ月〜1年）
- WebSocketによるリアルタイム通信
- 複数アンケートの管理機能
- 回答の詳細分析機能
- カスタムテーマ設定
- 質問タイプの追加（画像選択、スライダーなど）

### 8.3 AI活用の将来展望
- AIによる回答データの自動分析と洞察の提供
- AIを活用したアンケート質問の自動生成・最適化
- 自然言語処理によるテキスト回答の感情分析
- AIによるUIの自動最適化
- AIを活用した回答予測と傾向分析

## 9. 開発・テスト環境

### 9.1 開発環境
- Node.js 18.0.0以上
- npm, yarn, またはpnpm
- Git
- Vercel AI（v0）との連携環境

### 9.2 テスト環境
- Jest, React Testing Libraryによる単体テスト
- Cypress, Playwright によるE2Eテスト（将来的に実装）

### 9.3 デプロイ環境
- Vercelによるホスティング
- GitHub連携によるCI/CD

## 10. プロジェクト管理

### 10.1 開発フェーズ
1. 要件定義・設計フェーズ（AI協働）
2. 基本機能実装フェーズ（AI主導コード生成）
3. UI/UX改善フェーズ（開発者とAIの協働）
4. テスト・バグ修正フェーズ（AI支援によるデバッグ）
5. リリース・フィードバック収集フェーズ

### 10.2 優先順位
1. メイン画面と回答画面の基本機能
2. リアルタイム更新機能
3. 管理者機能
4. UI/UX改善
5. 拡張機能

### 10.3 AI駆動開発のイテレーション
- 短いイテレーションサイクル（1-3日）
- 各機能ごとにAIとの対話セッションを設定
- 定期的なコードレビューと改善

## 11. リスク管理

### 11.1 技術的リスク
- リアルタイム更新の遅延が大きくなる可能性
  - 対策: ポーリング間隔の最適化、将来的にWebSocketへの移行
- 多数の同時アクセスによるパフォーマンス低下
  - 対策: 負荷テストの実施、スケーラブルな設計

### 11.2 プロジェクト管理リスク
- 要件の変更や追加による開発遅延
  - 対策: アジャイル開発手法の採用、MVPの明確化
- リソース不足
  - 対策: 優先順位の明確化、フェーズ分けによる段階的開発

### 11.3 AI駆動開発特有のリスク
- AIが生成したコードの品質や最適性の問題
  - 対策: 人間によるコードレビュー、テストカバレッジの向上
- AIの知識の限界や誤解
  - 対策: 明確な指示と要件の提示、結果の検証
- AIへの過度な依存
  - 対策: 開発者のスキル維持、重要な判断は人間が行う
- AIの提案の一貫性の欠如
  - 対策: 設計原則とアーキテクチャの文書化、定期的な全体レビュー

## 12. 用語集

- **プレゼンター**: アンケートを作成・管理し、結果を表示する側のユーザー
- **参加者**: アンケートに回答する側のユーザー
- **リアルタイム更新**: 回答がほぼ即時に集計結果に反映される機能
- **ポーリング**: 定期的にサーバーにデータを問い合わせる方式
- **WebSocket**: 双方向通信を可能にするプロトコル
- **QRコード**: スマートフォンなどで読み取り可能な二次元バーコード
- **AI駆動開発**: AIと人間の開発者が協働してソフトウェアを開発するアプローチ
- **v0**: Vercelが提供するAIアシスタント

## 13. AI駆動開発の成果と学び

### 13.1 開発プロセスの記録
本プロジェクトでは、AI駆動開発の過程を記録し、その効果と課題を分析する。これにより、将来のプロジェクトにおけるAI活用の改善に役立てる。

### 13.2 知識の共有
AI駆動開発を通じて得られた知見や学びを、開発コミュニティと共有する。これにより、AIと人間の協働による開発手法の発展に貢献する。

## 14. 承認

本要件定義書は、プロジェクト開発者によって確認され、承認されるものとする。
要件の変更が必要な場合は、開発者とAIアシスタントの協議により更新する。

